{
    "sourceFile": "extraction/src/bin/extraction/pdla.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1724538840078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1724538840078,
            "name": "Commit-0",
            "content": "use super::extraction_config::Config;\nuse super::pdf::split_pdf;\nuse reqwest::{multipart, Client as ReqwestClient};\nuse serde_json::Value;\nuse std::{\n    fs,\n    io::Write,\n    path::{Path, PathBuf},\n};\nuse tempdir::TempDir;\nuse tempfile::NamedTempFile;\nuse tokio::sync::OnceCell;\nuse extraction::models::extraction::extraction::ModelInternal;\n\nstatic REQWEST_CLIENT: OnceCell<ReqwestClient> = OnceCell::const_new();\n\nasync fn get_reqwest_client() -> &'static ReqwestClient {\n    REQWEST_CLIENT\n        .get_or_init(|| async { ReqwestClient::new() })\n        .await\n}\n\nasync fn call_pdla_api(\n    url: &str,\n    file_path: &Path,\n    fast: bool,\n) -> Result<String, Box<dyn std::error::Error>> {\n    let client = get_reqwest_client().await;\n\n    let file_name = file_path\n        .file_name()\n        .ok_or_else(|| format!(\"Invalid file name: {:?}\", file_path))?\n        .to_str()\n        .ok_or_else(|| format!(\"Non-UTF8 file name: {:?}\", file_path))?\n        .to_string();\n    let file_fs = fs::read(file_path).expect(\"Failed to read file\");\n    let part = multipart::Part::bytes(file_fs).file_name(file_name);\n\n    let form = multipart::Form::new()\n        .part(\"file\", part)\n        .text(\"fast\", fast.to_string());\n\n    let response = client\n        .post(url)\n        .multipart(form)\n        .send()\n        .await?\n        .error_for_status()?;\n    Ok(response.text().await?)\n}\n\nasync fn handle_fast_requests(file_path: &Path) -> Result<String, Box<dyn std::error::Error>> {\n    let config = Config::from_env()?;\n    let url = config.pdla_fast_url;\n    call_pdla_api(&url, file_path, true).await\n}\n\nasync fn handle_high_quality_requests(\n    file_path: &Path,\n) -> Result<String, Box<dyn std::error::Error>> {\n    let config = Config::from_env()?;\n    let url = config.pdla_url;\n    call_pdla_api(&url, file_path, false).await\n}\n\nasync fn process_file(\n    file_path: &Path,\n    batch_size: Option<i32>,\n    model: ModelInternal,\n) -> Result<String, Box<dyn std::error::Error>> {\n    let mut temp_files: Vec<PathBuf> = vec![];\n    let temp_dir = TempDir::new(\"split_pdf\")?;\n    if let Some(batch_size) = batch_size {\n        temp_files = split_pdf(file_path, batch_size as usize, temp_dir.path())?;\n    } else {\n        temp_files.push(file_path.to_path_buf());\n    }\n    let mut combined_output = Vec::new();\n    let mut page_offset = 0;\n\n    for temp_file in &temp_files {\n        let json_output = if model == ModelInternal::PdlaFast {\n            handle_fast_requests(&temp_file).await?\n        } else if model == ModelInternal::Pdla {\n            handle_high_quality_requests(&temp_file).await?\n        } else {\n            return Err(format!(\"Invalid model: {}\", model).into());\n        };\n\n        let mut batch_output: Vec<Value> = serde_json::from_str(&json_output)?;\n        for item in &mut batch_output {\n            if let Some(page_number) = item.get_mut(\"page_number\") {\n                *page_number = serde_json::json!(page_number.as_i64().unwrap() + page_offset);\n            }\n        }\n        combined_output.extend(batch_output);\n        page_offset += batch_size.unwrap_or(1) as i64;\n    }\n\n    Ok(serde_json::to_string(&combined_output)?)\n}\n\npub async fn pdla_extraction(\n    file_path: &Path,\n    model: ModelInternal,\n    batch_size: Option<i32>,\n) -> Result<PathBuf, Box<dyn std::error::Error>> {\n    let json_output = process_file(file_path, batch_size, model).await?;\n\n    let mut output_temp_file = NamedTempFile::new()?;\n    output_temp_file.write_all(json_output.as_bytes())?;\n\n    Ok(output_temp_file.into_temp_path().keep()?.to_path_buf())\n}\n"
        }
    ]
}